// Copyright 2021 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hashtable

import (
	"bytes"
	"unsafe"

	"github.com/matrixorigin/matrixone/pkg/vm/process"
)

type tStringCell struct {
	hash   [8]uint64
	key    [8][]byte
	mapped [8]uint64
}

type MockStringHashTable struct {
	bucketCntBits uint8
	bucketCnt     uint64
	elemCnt       uint64
	maxElemCnt    uint64
	rawData       []byte
	bucketData    []tStringCell
}

func (ht *MockStringHashTable) Init(proc *process.Process) error {
	cSize := int64(320)
	var bucketData []byte
	var err error
	if proc != nil {
		bucketData, err = proc.Alloc(cSize * kInitialBucketCnt)
	} else {
		bucketData = make([]byte, cSize*kInitialBucketCnt)
	}
	if err != nil {
		return err
	}

	ht.bucketCntBits = kInitialBucketCntBits
	ht.bucketCnt = kInitialBucketCnt
	ht.elemCnt = 0
	ht.maxElemCnt = kInitialBucketCnt * kDefaultLoadFactor
	ht.rawData = bucketData
	ht.bucketData = unsafe.Slice((*tStringCell)(unsafe.Pointer(&bucketData[0])), cap(bucketData)/int(cSize))[:kInitialBucketCnt]

	return nil
}

func (ht *MockStringHashTable) Insert(hash uint64, key []byte, proc *process.Process) (inserted bool, value *uint64, err error) {
	err = ht.resizeOnDemand(proc)
	if err != nil {
		return
	}

	if hash == 0 {
		hash = crc32BytesHashAsm(unsafe.Pointer(&key[0]), len(key))
	}

	inserted, idx, pos := ht.findBucket(hash, key)
	if inserted {
		ht.elemCnt++
		ht.bucketData[idx].hash[pos] = hash
		ht.bucketData[idx].key[pos] = key
	}

	value = &ht.bucketData[idx].mapped[pos]

	return
}

func (ht *MockStringHashTable) Find(hash uint64, key []byte) *uint64 {
	if hash == 0 {
		hash = crc32BytesHashAsm(unsafe.Pointer(&key[0]), len(key))
	}
	_, idx, pos := ht.findBucket(hash, key)

	return &ht.bucketData[idx].mapped[pos]
}

func (ht *MockStringHashTable) findBucket(hash uint64, key []byte) (empty bool, idx, pos uint64) {
	mask := ht.bucketCnt - 1
	var equal bool
	bucket := hash & mask
	cellMask := (ht.bucketCnt >> 3) - 1
	for idx = bucket / 8; true; idx = (idx + 1) & cellMask {
		for pos = 0; pos < 8; pos++ {
			empty, equal = ht.bucketData[idx].hash[pos] == 0, ht.bucketData[idx].hash[pos] == hash && bytes.Equal(ht.bucketData[idx].key[pos], key)
			if empty || equal {
				return
			}
		}
	}

	return
}

func (ht *MockStringHashTable) resizeOnDemand(proc *process.Process) error {
	if ht.elemCnt < ht.maxElemCnt {
		return nil
	}

	var newBucketCntBits uint8
	if ht.bucketCnt >= 23 {
		newBucketCntBits = ht.bucketCntBits + 1
	} else {
		newBucketCntBits = ht.bucketCntBits + 2
	}

	newBucketCnt := int64(1) << newBucketCntBits
	newMaxElemCnt := uint64(float64(newBucketCnt) * kDefaultLoadFactor)

	cSize := int64(40)
	var newData []byte
	var err error
	if proc != nil {
		newData, err = proc.Alloc(cSize * newBucketCnt)
	} else {
		newData = make([]byte, cSize*newBucketCnt)
	}
	if err != nil {
		return err
	}

	newBucketData := unsafe.Slice((*tStringCell)(unsafe.Pointer(&newData[0])), cap(newData)/int(cSize))[:newBucketCnt]

	copy(newData, ht.rawData)
	if proc != nil {
		proc.Free(ht.rawData)
	}
	ht.rawData = newData
	ht.bucketData = newBucketData

	oldBucketCnt := ht.bucketCnt
	ht.bucketCntBits = newBucketCntBits
	ht.bucketCnt = uint64(newBucketCnt)
	ht.bucketData = newBucketData
	ht.maxElemCnt = newMaxElemCnt

	var idx, pos uint64
	oldCellCnt := oldBucketCnt / 8
	for idx = 0; idx < oldCellCnt; idx++ {
		for pos = 0; pos < 8; pos++ {
			if ht.bucketData[idx].hash[pos] != 0 {
				ht.reinsert(idx, pos)
			}
		}
	}

	pos = 0
	for ht.bucketData[idx].hash[pos] != 0 {
		ht.reinsert(idx, pos)
		pos++
		if pos == 8 {
			idx++
			pos = 0
		}
	}

	return nil
}

func (ht *MockStringHashTable) reinsert(idx, pos uint64) {
	_, newIdx, newPos := ht.findBucket(ht.bucketData[idx].hash[pos], ht.bucketData[idx].key[pos])
	if newIdx == idx && newPos == pos {
		return
	}

	ht.bucketData[newIdx].hash[newPos] = ht.bucketData[idx].hash[pos]
	ht.bucketData[newIdx].key[newPos] = ht.bucketData[idx].key[pos]
	ht.bucketData[newIdx].mapped[newPos] = ht.bucketData[idx].mapped[pos]
	ht.bucketData[idx].hash[pos] = 0
	ht.bucketData[idx].key[pos] = nil
	ht.bucketData[idx].mapped[pos] = 0
}

func (ht *MockStringHashTable) Cardinality() uint64 {
	return ht.elemCnt
}

func (ht *MockStringHashTable) Destroy(proc *process.Process) {
	if ht == nil || proc == nil {
		return
	}

	if ht.rawData != nil {
		proc.Free(ht.rawData)
		ht.rawData = nil
		ht.bucketData = nil
	}
}
